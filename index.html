<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>连线游戏</title>
    <script src="./pixi.js"></script>
    <script src="./gsap.min.js"></script>
    <script src="./stage-data.js"></script>
    <script src="./edit-game.js"></script>
</head>
<body>
    <style>
        body{
            margin: 0px;
            padding: 0px;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        canvas{
            margin: 0px;
            padding: 0px;
            vertical-align: bottom;
        }
    </style>
    <script type="module">
        const app = new PIXI.Application();
        await app.init({
            resizeTo: window,
            backgroundColor: '#999999',
        })
        document.body.appendChild(app.canvas);
        
        // app.stage.interactive = true;
        // let dpr = window.devicePixelRatio
        // let scaleX = window.innerWidth / (app.renderer.width / dpr);
        // let scaleY = window.innerHeight / (app.renderer.height / dpr);
        // let scale = Math.min(scaleX,scaleY);
        // app.stage.scale.set(scale, scale);
        // app.renderer.resize(window.innerWidth * dpr, window.innerHeight * dpr);

        let stageComplete = false;
        let ww = app.renderer.width;
        let wh = app.renderer.height;
        
        let isEditMode = false;
        let linePointsIndexArr = [];//记录线段的点的排列坐标

        let stageLevel = 0;//关卡
        let lineWidth = 2; //线宽度
        let lineColorIntersect = '#ff1972'; //线相交的颜色
        let lineColorNormal = '#0c86ff';//线不相交的颜色
        let lineAlpha = 0.8;
        let pointRadius = 8;//点半径
        let pointColor = '#3071ff'; //点颜色
        let points = [];
        let lines = [];
        let selectedPoints = [];

        let containerUi = new PIXI.Container();
        let mainContainer  = new PIXI.Container();
        let lineContainer = new PIXI.Container();
        let pointContainer = new PIXI.Container();
        let pointZIndexStart = 999999;
        let lineZIndexStart = 9999;

        mainContainer.addChild(lineContainer);
        mainContainer.addChild(pointContainer); 
        mainContainer.addChild(containerUi); 

        app.stage.addChild(mainContainer);

        function createText(){
            let text = new PIXI.Text({
                text : '点击交换节点让线不相交', 
                style : {
                    fontFamily: 'Microsoft Yahei',
                    fontSize: 16,
                    fill: '#fff',
                    align: 'center'
                }

            });
            text.x = app.renderer.width / 2;
            text.y = 32;
            text.anchor.set(0.5);
            containerUi.addChild(text);
        }
        
        // 创建点
        function createPoint(x, y) {
            let point = new PIXI.Graphics();
            point.circle(0, 0, pointRadius);
            point.fill({ color: pointColor, alpha: 1 });
            point.x = x;
            point.y = y;
            point.interactive = true;
            point.buttonMode = true; 
            point.on('pointerdown', onPointClick);
            // app.stage.addChild(point);
            points.push(point);
            point.zIndex = pointZIndexStart;
            pointZIndexStart--;
            pointContainer.addChild(point)
        }

        // 创建线
        function createLine(point1, point2) {
            let line = new PIXI.Graphics();
            line.moveTo(point1.x, point1.y);
            line.lineTo(point2.x, point2.y);
            line.stroke({ width: lineWidth, color: 0x33ff00 ,alpha : lineAlpha });
            lines.push({ line, point1, point2 });
            line.zIndex = lineZIndexStart;
            lineZIndexStart--;
            pointContainer.addChild(line)
        }
        // 点击点时的处理
        function onPointClick() { 
            if(stageComplete){
                return;
            }
            if(selectedPoints.length){
                // 点击同一个点时不做处理
                if(this.x == selectedPoints[0].x && this.y == selectedPoints[0].y){
                    return;
                }
            }            
            if (selectedPoints.length < 2) { 
                selectedPoints.push(this); 
                this.tint = 0xff0000;
                if (selectedPoints.length === 2) { 
                    if(isEditMode){
                        createLine(selectedPoints[0],selectedPoints[1]);
                        selectedPoints = [];
                    }else{
                        swapPoints(selectedPoints[0], selectedPoints[1]); 
                        selectedPoints.forEach(i => i.tint = 0xffffff);
                    }
                } 
            } 
        }
        function getIntersections(){
            let intersections = new Set();
            // 首先标记出相交的线段
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    if(doIntersect(lines[i].point1,lines[i].point2,lines[j].point1,lines[j].point2)){                   
                        intersections.add(lines[i]);
                        intersections.add(lines[j]);
                    }
                }
            }
            return intersections;
        }
        // 检查线段是否相交
        function checkIntersections(intersections) {
            // let intersections = getIntersections();
            // 然后更新线段的颜色
            lines.forEach(line => {
                line.line.clear();
                line.line.moveTo(line.point1.x, line.point1.y);
                line.line.lineTo(line.point2.x, line.point2.y);
                if (intersections.has(line)) {
                    line.line.stroke({ width: lineWidth, color: lineColorIntersect ,alpha : lineAlpha });
                } else {
                    line.line.stroke({ width: lineWidth, color: lineColorNormal ,alpha : lineAlpha });
                }
            });
        }

        // 交换两个点的位置并动画展示
        function swapPoints(point1, point2) {
            let tempX = point1.x;
            let tempY = point1.y;

            // 创建动画
            gsap.to(point1, {
                x: point2.x,
                y: point2.y,
                duration: 0.5,
                onUpdate: updateLines
            });
            gsap.to(point2, {
                x: tempX,
                y: tempY,
                duration: 0.5,
                onUpdate: updateLines,
                onComplete: () => {
                    // 动画完成后检查线段是否相交       
                    let intersections = getIntersections();
                    if(intersections.size){
                        checkIntersections(intersections);
                    }else{
                        stageComplete = true;
                        setTimeout(()=>{
                            // 游戏完成
                            stageLevel++;
                            initGame();
                        },1000)

                    }
                    selectedPoints = [];
                }
            });
        }
        // 更新线的位置
        function updateLines() {
            lines.forEach(line => {
                line.line.clear();
                line.line.moveTo(line.point1.x, line.point1.y);
                line.line.lineTo(line.point2.x, line.point2.y);
                line.line.stroke({ width: lineWidth, color: lineColorNormal ,alpha : lineAlpha });
            });
            checkIntersections(getIntersections());
        }


        function doIntersect(p1, q1, p2, q2) {
            function orientation(p, q, r) {
                let val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (val === 0) return 0;  // collinear
                return (val > 0) ? 1 : 2; // clock or counterclock wise
            }

            function onSegment(p, q, r) {
                if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) {
                    return true;
                }
                return false;
            }

            function isEndPoint(p, q1, q2) {
                return (p.x === q1.x && p.y === q1.y) || (p.x === q2.x && p.y === q2.y);
            }

            if (isEndPoint(p1, p2, q2) || isEndPoint(q1, p2, q2) || 
                isEndPoint(p2, p1, q1) || isEndPoint(q2, p1, q1)) {
                return false;
            }

            let o1 = orientation(p1, q1, p2);
            let o2 = orientation(p1, q1, q2);
            let o3 = orientation(p2, q2, p1);
            let o4 = orientation(p2, q2, q1);

            // General case
            if (o1 !== o2 && o3 !== o4) {
                return true;
            }

            // Special Cases
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;

            return false; // Doesn't fall in any of the above cases
        }

        // 随机取数
        function getRandomTwo(arr) {
            if (arr.length < 2) {
                throw new Error("数组长度必须至少为2");
            }

            // 随机选取第一个索引
            const index1 = Math.floor(Math.random() * arr.length);
            let index2 = index1;

            // 确保第二个索引与第一个不同
            while (index2 === index1) {
                index2 = Math.floor(Math.random() * arr.length);
            }
            // 返回这两个数
            return [arr[index1], arr[index2]];
        }

        // 写标题
        createText();

        function resetGame(){
            if(points.length){
                points.map((item,index)=>{
                    points[index].clear();
                })
            }
            if(lines.length){
                lines.map((item,index)=>{
                    lines[index].line.clear();
                })
            }
            points = [];
            lines = [];
        }

        function initGame(){
            resetGame();
            if(stageLevel >= STAGE_DATA.length){
                // 游戏通关
                let text = new PIXI.Text({
                    text : '游戏通关了', 
                    style : {
                        fontFamily: 'Microsoft Yahei',
                        fontSize: 18,
                        fill: '#fff',
                        align: 'center'
                    }
                });
                text.x = app.renderer.width / 2;
                text.y = app.renderer.height/2;
                text.anchor.set(0.5);
                containerUi.addChild(text);
                return;
            }
            stageComplete = false;
            let pointPositionArr = getGridPosition(pointRadius);
            let map = JSON.parse( STAGE_DATA[stageLevel].map );
            let stagePoints = map.points;
            let stageLines = map.lines;
            for (let index = 0; index < stagePoints.length; index++) {
                const element = stagePoints[index];
                let x = pointPositionArr[element[0]][element[1]].x;
                let y = pointPositionArr[element[0]][element[1]].y;
                createPoint(x,y); 
            }

            for (let index = 0; index < stageLines.length; index++) {
                const element = stageLines[index];
                let x1 = pointPositionArr[element.point1[0]][element.point1[1]].x;
                let y1 = pointPositionArr[element.point1[0]][element.point1[1]].y;
                let x2 = pointPositionArr[element.point2[0]][element.point2[1]].x;
                let y2 = pointPositionArr[element.point2[0]][element.point2[1]].y;
                let point1 = null;
                let point2 = null;
                //要找到上面创建的点，不然移动的时候会不跟着动
                points.map((item)=>{
                    if(item.x == x1 && item.y == y1){
                        point1 = item;
                    }
                    if(item.x == x2 && item.y == y2){
                        point2 = item;
                    }
                })
                if(point1 && point2){
                    createLine(point1, point2); 
                }
            }
            randomLines();
        }
        function randomLines(){
            // 随机线 随机取两条线，交换起点的位置
            let randomIndex = getRandomTwo(lines)
            let tmpX1 = randomIndex[0].point1.x;
            let tmpY1 = randomIndex[0].point1.y;       
            randomIndex[0].point1.x = randomIndex[1].point1.x;
            randomIndex[0].point1.y = randomIndex[1].point1.y;
            randomIndex[1].point1.x = tmpX1;
            randomIndex[1].point1.y = tmpY1;

            // 首先标记出相交的线段
            let intersections = new Set();            
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    if(doIntersect(lines[i].point1,lines[i].point2,lines[j].point1,lines[j].point2)){                   
                        intersections.add(lines[i]);
                        intersections.add(lines[j]);
                    }
                }
            }
            let intersectionsCount = STAGE_DATA[stageLevel].intersections;
            if(!intersections.size || intersections.size < intersectionsCount){
                randomLines();
            }
            updateLines();
        }

        function initEditMode(){
            /*
                编辑模式下，不要生成相同的线或者反方向的线
            */
            isEditMode = true;
            //生成所有的点
            let pointArr = getGridPosition(pointRadius);
            for (let index = 0; index < pointArr.length; index++) {
                const element = pointArr[index];
                for (let idx = 0; idx < element.length; idx++) {
                    const point = element[idx];
                    let row = index;
                    let column = idx;
                    createPoint(point.x,point.y)
                    points[points.length - 1].row = row;
                    points[points.length - 1].column = column;
                }
            }

            let text = new PIXI.Text({
                text : '保存关卡', 
                style : {
                    fontFamily: 'Microsoft Yahei',
                    fontSize: 16,
                    fill: '#fff',
                    align: 'center'
                }
            });
            text.x = app.renderer.width / 2;
            text.y = app.renderer.height - 30;
            text.anchor.set(0.5);

            text.interactive = true;
            text.buttonMode = true; 
            text.on('pointerdown', onConfirmClick);
            containerUi.addChild(text);
        }

        // 点击保存关卡
        function onConfirmClick(){
            let pointArr = [];
            let lineArr = [];
            for (let index = 0; index < lines.length; index++) {
                const element = lines[index];
                let row1 = element.point1.row;
                let column1 = element.point1.column;

                let row2 = element.point2.row;
                let column2 = element.point2.column;

                pointArr.push(row1 + ',' + column1);
                pointArr.push(row2 + ',' + column2)

                lineArr.push(
                    {
                        point1 : [row1,column1],
                        point2 : [row2,column2],
                    }
                )
            }
            const uniqueArr = Array.from(new Set(pointArr)); //点去重
            for (let index = 0; index < uniqueArr.length; index++) {
                const element = uniqueArr[index];
                let tmp = element.split(',');
                uniqueArr[index] = [parseInt(tmp[0]),parseInt(tmp[1])];
            }
            let stageData = {
                points : uniqueArr,
                lines : lineArr,
            }
            console.info(JSON.stringify(stageData)) //把这个数据保存到关卡数据里即可
        }

        function getUrlParams() {
            var params = {};
            var url = window.location.href;
            var regex = /[?&]+([^=&]+)=([^&]*)/g;
            var match;
            while (match = regex.exec(url)) {
                params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
            }
            return params;
        }

        window.onload = function(){
            let params= getUrlParams();
            console.info(params)
            if(params && params.edit_mode){
                initEditMode(); //用来编辑关卡
            }else{
                initGame();
            }
        }
        
        // let centerX = ww/2;
        // let centerY = wh/2;
        // createPoint(centerX - 50,centerY - 50); 
        // createPoint(centerX + 50,centerY - 50); 
        // createPoint(centerX + 50,centerY + 50); 
        // createPoint(centerX - 50,centerY + 50); 

        // createLine(points[0], points[1]); 
        // createLine(points[1], points[2]); 
        // createLine(points[2], points[3]); 
        // createLine(points[3], points[0]); 
        // checkIntersections();
        // randomLine();
    </script>
</body>
</html>